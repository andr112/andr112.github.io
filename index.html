<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>胖墩记忆</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="胖墩记忆">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="胖墩记忆">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="胖墩记忆">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="胖墩记忆" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">胖墩记忆</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">小胖胖的学习、工作和生活...</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-彻底搞懂Android文件存储-内部存储，外部存储以及各种存储路径" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/03/彻底搞懂Android文件存储-内部存储，外部存储以及各种存储路径/" class="article-date">
  <time datetime="2018-04-03T09:51:41.000Z" itemprop="datePublished">2018-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/03/彻底搞懂Android文件存储-内部存储，外部存储以及各种存储路径/">彻底搞懂Android文件存储(内部存储，外部存储以及各种存储路径)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  今天有人问我“外部存储是单指sd卡么?”“手机内部存储是看不到的, 对吧?”（其他程序是否可访问获取）。存取文件，开发中大家都会用，功能都能实现。但很多都说不清楚。诸如，设置里面应用清除数据、清除缓存数据，都是清除的什么数据；各个安卓系统版本不同，外部存储路径不同，等等。关于文件存取相关的东西比较多，做为开发是需要梳理清楚的。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存与PC的内存是一样的，是用来运行程序，不能用来永久存储数据，手机一旦关机，在内存中的所有数据都将会丢失，内存也是现在人类制造的所有电子设备所必需拥有的。</p>
<h2 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h2><p>内部存储是内存吗？不是。内部存储是用于存储Andoid 设备的操作系统和应用程序的存储介质。也就是说，Android设备中的Android系统和应用程序（APK文件）都是存在内部存储区的。例如手机的/system/目录、/data/目录等。是可以永久保存数据的。</p>
<p>将文件存储于内部存储中，文件默认只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下。也就是说应用创建于内部存储的文件，与这个应用是关联起来的。当一个应用卸载之后，内部存储中的这些文件也被删除。从技术上来讲如果你在创建内部存储文件的时候将文件属性设置成可读，其他app能够访问自己应用的数据，前提是他知道你这个应用的包名，如果一个文件的属性是私有（private），那么即使知道包名其他应用也无法访问。</p>
<p>内部存储空间十分有限，我们要尽量避免使用。</p>
<p>Shared Preferences和SQLite数据库都是存储在内部存储空间上的。内部存储一般用Context来获取和操作。 </p>
<p>访问内部存储的API方法：<br>1、Environment.getDataDirectory()<br>2、getFilesDir().getAbsolutePath()<br>3、getCacheDir().getAbsolutePath()<br>4、getDir(“myFile”, MODE_PRIVATE).getAbsolutePath() </p>
<h2 id="外部存储"><a href="#外部存储" class="headerlink" title="外部存储"></a>外部存储</h2><p>pc机（电脑）自带的硬盘算是内部存储，U盘或者移动硬盘就是外部存储。</p>
<p>安卓4.4（API19）以前的手机，内置存储（机身存储：手机自身带的存储卡）就是内部存储，外部存储就是扩展的SD卡。</p>
<p>但从4.4的系统开始，很多的中高端机器都将自己的机身存储扩展到了8G以上、16G、32G等。4.4系统及以上的手机将机身存储存储（手机自身带的存储叫做机身存储）在概念上分成了”内部存储internal” 和”外部存储external” 两部分。如果4.4系统及以上的手机插SD卡，SD卡也是外部存储。4.4系统及以上的手机的外部存储可能包含两部分，一是机身存储的外部存储部分，一是SD卡部分。在4.4以后的系统中，API提供了这样一个方法来遍历手机的外部存储路径：<br>    File[] files;<br>    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {<br>        files = getExternalFilesDirs(Environment.MEDIA_MOUNTED);<br>        for(File file:files){<br>            Log.e(“main”,file);<br>        }<br>    }<br>访问外部存储的API方法：<br>1、Environment.getExternalStorageDirectory().getAbsolutePath()<br>2、Environment.getExternalStoragePublicDirectory(“”).getAbsolutePath()<br>3、getExternalFilesDir(“”).getAbsolutePath()<br>4、getExternalCacheDir().getAbsolutePath() </p>
<h2 id="存储路径"><a href="#存储路径" class="headerlink" title="存储路径"></a>存储路径</h2><p>不同的Android版本，存在一些差异。</p>
<p>基于荣耀7的（系统版本6.0）路径：<br>1、Environment.getDataDirectory() = /data<br>这个方法是获取内部存储的根路径<br>2、getFilesDir().getAbsolutePath() = /data/user/0/packname/files<br>这个方法是获取某个应用在内部存储中的files路径<br>3、getCacheDir().getAbsolutePath() = /data/user/0/packname/cache<br>这个方法是获取某个应用在内部存储中的cache路径<br>4、getDir(“myFile”, MODE_PRIVATE).getAbsolutePath() = /data/user/0/packname/app_myFile<br>这个方法是获取某个应用在内部存储中的自定义路径<br>方法2,3,4的路径中都带有包名，说明他们是属于某个应用<br>…………………………………………………………………………………………<br>5、Environment.getExternalStorageDirectory().getAbsolutePath() = /storage/emulated/0<br>这个方法是获取外部存储的根路径<br>6、Environment.getExternalStoragePublicDirectory(“”).getAbsolutePath() = /storage/emulated/0<br>这个方法是获取外部存储的根路径<br>7、getExternalFilesDir(“”).getAbsolutePath() = /storage/emulated/0/Android/data/packname/files<br>这个方法是获取某个应用在外部存储中的files路径<br>8、getExternalCacheDir().getAbsolutePath() = /storage/emulated/0/Android/data/packname/cache<br>这个方法是获取某个应用在外部存储中的cache路径<br>注意：其中方法7和方法8如果在4.4以前的系统中getExternalFilesDir(“”)和getExternalCacheDir()将返回null，即4.4以前的系统没插SD卡的话，就没有外部存储；而4.4及以后的系统外部存储包括两部分，getExternalFilesDir(“”)和getExternalCacheDir()获取的是机身存储的外部存储部分，即4.4及以后的系统你不插SD卡，它也有外部存储，既然getExternalFilesDir(“”)和getExternalCacheDir()获取的是机身存储的外部存储部分，那么怎么获取SD卡的存储路径呢，通过上面提到的getExternalFilesDirs(Environment.MEDIA_MOUNTED)方法来获取。<br>…………………………………………………………………………………………<br>Environment.getDownloadCacheDirectory() = /cache<br>Environment.getRootDirectory() = /system<br>这两个方法，每个版本的android系统都一样<br>………………………………………………………………………………………… </p>
<p>/data目录下的文件物理上存放在我们通常所说的内部存储里面<br>/storage目录下的文件物理上存放在我们通常所说的外部存储里面 ，API方法都带了一个External<br>/system用于存放系统文件，/cache用于存放一些缓存文件，物理上它们也是存放在内部存储里面的 </p>
<h2 id="设置里面应用清除数据、清除缓存数据，都是清除的什么数据"><a href="#设置里面应用清除数据、清除缓存数据，都是清除的什么数据" class="headerlink" title="设置里面应用清除数据、清除缓存数据，都是清除的什么数据"></a>设置里面应用清除数据、清除缓存数据，都是清除的什么数据</h2><p>1.清除缓存：应用程序在运行过程中需要经过很多过程，如读入程序，计算，输入输出等等，这些过程中会产生很多的数据，它们在内存中，以供程序运行时调用。清除缓存清除的是APP运行过程中所产生的临时数据。 </p>
<ol>
<li>清除数据：清除数据是真正的删除了我们保存在文件中的数据（永久性数据）,当我们在设置里面清除了某个应用的数据，那么/data/user/0/packname/和/storage/emulated/0/Android/data/packname/下的文件里面的数据会全部删除，包括cache，files，lib，shared_prefs等等。</li>
</ol>
<h2 id="内部存储本身就比较小，而且已经存储了一些系统的文件，我们因尽量不要使用。一般做法："><a href="#内部存储本身就比较小，而且已经存储了一些系统的文件，我们因尽量不要使用。一般做法：" class="headerlink" title="内部存储本身就比较小，而且已经存储了一些系统的文件，我们因尽量不要使用。一般做法："></a>内部存储本身就比较小，而且已经存储了一些系统的文件，我们因尽量不要使用。一般做法：</h2><pre><code>public static String getFilePath(Context context,String dir) {
    String directoryPath=&quot;dirName&quot;;
    if (MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ) {//判断外部存储是否可用 
        directoryPath =context.getExternalFilesDir(dir).getAbsolutePath();
        }else{//没外部存储就使用内部存储  
        directoryPath=context.getFilesDir()+File.separator+dir;
        }
        File file = new File(directoryPath);
        if(!file.exists()){//判断文件目录是否存在
        file.mkdirs();
        }
    return directoryPath;
}
</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.csdn.net/kenvin0124/article/details/52281856" target="_blank" rel="external">Android中内存、内部存储及外部存储的区别</a></li>
<li><a href="https://blog.csdn.net/u010937230/article/details/73303034" target="_blank" rel="external">彻底搞懂Android文件存储—内部存储，外部存储以及各种存储路径解惑</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/03/彻底搞懂Android文件存储-内部存储，外部存储以及各种存储路径/" data-id="cjfthdfck000fvz7qyj52huyu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-smali-语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/29/smali-语法/" class="article-date">
  <time datetime="2018-03-29T05:17:07.000Z" itemprop="datePublished">2018-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/29/smali-语法/">smali 语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="smali是什么"><a href="#smali是什么" class="headerlink" title="smali是什么"></a>smali是什么</h2><p>Smali是Dalvik的寄存器语言，它与Java的关系，简单理解就是汇编之于C。</p>
<h2 id="smali文件是哪来的，获取方法"><a href="#smali文件是哪来的，获取方法" class="headerlink" title="smali文件是哪来的，获取方法"></a>smali文件是哪来的，获取方法</h2><p>Smali代码是安卓APK反编译而来的。Smali文件和Java文件一一对应。获取Smali文件，我们需要下载一个辅助工具：ApkTool 。apktool这个命令行工具，最常用的命令有：</p>
<ul>
<li>反编译decode：<br>  apktool d xxx.apk</li>
<li>打包build：<br>  apktool b</li>
</ul>
<h2 id="Smali语法"><a href="#Smali语法" class="headerlink" title="Smali语法"></a>Smali语法</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><pre><code>V void (只能用于返回值类型) 
Z boolean
B byte
S short
C char
I int
J long（64位）
F float
D double（64位）
</code></pre><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>Lpackage/ObjectName; 相当于java中的package.ObjectName;<br>L 表示这是一个对象类型<br>package 该对象所在的包<br>ObjectName 对象名称<br>; 标识对象名称的结束<br>例如：Ltestdemo/hpp/cn/test/MainActivity;Ljava/lang/String;</p>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>[I :表示一个整形的一维数组，相当于java的int[];<br>对于多维数组，只要增加[ 就行了，[[I = int[][];注：每一维最多255个；</p>
<p>对象数组的表示形式：<br>[Ljava/lang/String 表示一个String的对象数组；</p>
<h3 id="寄存器与变量"><a href="#寄存器与变量" class="headerlink" title="寄存器与变量"></a>寄存器与变量</h3><p>android变量都是存放在寄存器中的，寄存器为32位，可以支持任何类型，其中long和double是64为的，需要使用两个寄存器保存。<br>寄存器采用v和p来命名，v表示本地寄存器，p表示参数寄存器。</p>
<p>例如：</p>
<pre><code>//===================================================================
private void print(String string) {
    Log.d(TAG, string);
}
//===================================================================
.method private print(Ljava/lang/String;)V
    .registers 3
    .param p1, &quot;string&quot;    # Ljava/lang/String;

    .prologue
    .line 29
    const-string v0, &quot;MainActivity&quot;

    invoke-static {v0, p1}, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I

    .line 30
    return-void
.end method
//===================================================================
</code></pre><p>.registers 3 说明该方法有三个寄存器，其中一个本地寄存器v0，两个参数寄存器p0,p1，细心的人可能会注意到没有看到p0，原因是p0存放的是this。如果是静态方法的话就只有2个寄存器了，不需要存this了。</p>
<h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><p>smali字节码是类似于汇编，如果有汇编基础，理解起来是非常容易的。<br>    move v0, v3 把v3寄存器的值移动到寄存器v0上<br>    const-string v0, “MainActivity” 把字符串”MainActivity”赋值给v0寄存器<br>    invoke-super　　调用父函数<br>    return-void　　函数返回void<br>    new-instance　　创建实例<br>    iput-object　　对象赋值<br>    iget-object　　调用对象<br>    invoke-static　　调用静态函数<br>    invoke-direct　　调用函数</p>
<p>例如：</p>
<pre><code>//===================================================================
@Override
public void onClick(View view) {
    String str = &quot;Hello World!&quot;;
    print(str);
}
//===================================================================
# virtual methods
# 参数类型为Landroid/view/View，返回类型为V
.method public onClick(Landroid/view/View;)V
    # 表示有三个寄存器
    .registers 3
    # 参数View类型的view变量对应的是寄存器p1
    .param p1, &quot;view&quot;    # Landroid/view/View;

    .prologue
    .line 24
    #将&quot;Hello World!&quot;字符串放到寄存器v0中
    const-string v0, &quot;Hello World!&quot;

    .line 25
    # 定义一个Ljava/lang/String类型的str变量对应本地寄存器v0
    .local v0, &quot;str&quot;:Ljava/lang/String;
    # 调用该类的print方法，该方法的参数类型为Ljava/lang/String，返回值为V
    # 调用print方法传入的参数为{p0, v0}，及print(p0, v0)，p0为this，v0为&quot;Hello World!&quot;字符串
    invoke-direct {p0, v0}, Ltestdemo/hpp/cn/annotationtest/MainActivity;-&gt;print(Ljava/lang/String;)V

    .line 26
    return-void
.end method
//===================================================================
</code></pre><h3 id="if判断语句"><a href="#if判断语句" class="headerlink" title="if判断语句"></a>if判断语句</h3><p>if判断一共有12条指令：</p>
<pre><code>if-eq vA, VB, cond_** 如果vA等于vB则跳转到cond_**。相当于if (vA==vB)
if-ne vA, VB, cond_** 如果vA不等于vB则跳转到cond_**。相当于if (vA!=vB)
if-lt vA, VB, cond_** 如果vA小于vB则跳转到cond_**。相当于if (vA&lt;vB)
if-le vA, VB, cond_** 如果vA小于等于vB则跳转到cond_**。相当于if (vA&lt;=vB)
if-gt vA, VB, cond_** 如果vA大于vB则跳转到cond_**。相当于if (vA&gt;vB)
if-ge vA, VB, cond_** 如果vA大于等于vB则跳转到cond_**。相当于if (vA&gt;=vB)

if-eqz vA, :cond_** 如果vA等于0则跳转到:cond_** 相当于if (VA==0)
if-nez vA, :cond_** 如果vA不等于0则跳转到:cond_**相当于if (VA!=0)
if-ltz vA, :cond_** 如果vA小于0则跳转到:cond_**相当于if (VA&lt;0)
if-lez vA, :cond_** 如果vA小于等于0则跳转到:cond_**相当于if (VA&lt;=0)
if-gtz vA, :cond_** 如果vA大于0则跳转到:cond_**相当于if (VA&gt;0)
if-gez vA, :cond_** 如果vA大于等于0则跳转到:cond_**相当于if (VA&gt;=0)
</code></pre><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>常用的循环结构有：迭代器循环，for循环，do while循环。</p>
<pre><code>import java.util.*;

public class demo{
    public static void main(String[]args)
    {
        Scanner s=new Scanner(System.in);
        int[] arr=new int[5];
        for(int i=0;i&lt;5;i++)
        {
            arr[i]=s.nextInt();
        }  
        for (int i:arr)
        {
            System.out.println(i);
        }

    }
}

.class public Ldemo;
.super Ljava/lang/Object;
.source &quot;demo.java&quot;


# direct methods
.method public constructor &lt;init&gt;()V
    .registers 1

    .prologue
    .line 3
    invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V

    return-void
.end method

.method public static main([Ljava/lang/String;)V
    .registers 7

    .prologue
    const/4 v5, 0x5

    const/4 v0, 0x0

    .line 6
    new-instance v2, Ljava/util/Scanner;

    sget-object v1, Ljava/lang/System;-&gt;in:Ljava/io/InputStream;

    invoke-direct {v2, v1}, Ljava/util/Scanner;-&gt;&lt;init&gt;(Ljava/io/InputStream;)V

    .line 7
    new-array v3, v5, [I

    move v1, v0

    .line 8
    :goto_c
    if-ge v1, v5, :cond_17

    .line 10
    invoke-virtual {v2}, Ljava/util/Scanner;-&gt;nextInt()I

    move-result v4

    aput v4, v3, v1

    .line 8
    add-int/lit8 v1, v1, 0x1

    goto :goto_c

    .line 12
    :cond_17
    array-length v1, v3

    :goto_18
    if-ge v0, v1, :cond_24

    aget v2, v3, v0

    .line 14
    sget-object v4, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;

    invoke-virtual {v4, v2}, Ljava/io/PrintStream;-&gt;println(I)V

    .line 12
    add-int/lit8 v0, v0, 0x1

    goto :goto_18

    .line 17
    :cond_24
    return-void
.end method
</code></pre><h3 id="switch分支语句"><a href="#switch分支语句" class="headerlink" title="switch分支语句"></a>switch分支语句</h3><p>1、case值递增的有规律 switch</p>
<pre><code>private String packedSwitch(int i) {  
    String str = null;  
    switch (i) {  
        case 0:  
            str = &quot;she is a baby&quot;;  
            break;  
        case 1:  
            str = &quot;she is a girl&quot;;  
            break;  
        case 2:  
            str = &quot;she is a woman&quot;;  
            break;  
        case 3:  
            str = &quot;she is an obasan&quot;;  
            break;  
        default:  
            str = &quot;she is a person&quot;;  
            break;  
    }  
    return str;  
}  

.method private packedSwitch(I)Ljava/lang/String;  
    .locals 1  
    .parameter &quot;i&quot;  
    .prologue  
    .line 21  
    const/4 v0, 0x0  
    .line 22  
    .local v0, str:Ljava/lang/String;  #v0为字符串，0表示null  
    packed-switch p1, :pswitch_data_0  #packed-switch分支，pswitch_data_0指定case区域  
    .line 36  
    const-string v0, &quot;she is a person&quot;  #default分支  
    .line 39  
    :goto_0      #所有case的出口  
    return-object v0 #返回字符串v0  
    .line 24  
    :pswitch_0    #case 0  
    const-string v0, &quot;she is a baby&quot;  
    .line 25  
    goto :goto_0  #跳转到goto_0标号处  
    .line 27  
    :pswitch_1    #case 1  
    const-string v0, &quot;she is a girl&quot;  
    .line 28  
    goto :goto_0  #跳转到goto_0标号处  
    .line 30  
    :pswitch_2    #case 2  
    const-string v0, &quot;she is a woman&quot;  
    .line 31  
    goto :goto_0  #跳转到goto_0标号处  
    .line 33  
    :pswitch_3    #case 3  
    const-string v0, &quot;she is an obasan&quot;  
    .line 34  
    goto :goto_0  #跳转到goto_0标号处  
    .line 22  
    nop  
    :pswitch_data_0  
    .packed-switch 0x0    #case  区域，从0开始，依次递增  
        :pswitch_0  #case 0  
        :pswitch_1  #case 1  
        :pswitch_2  #case 2  
        :pswitch_3  #case 3  
    .end packed-switch  
.end method
</code></pre><p>2、无规律的switch</p>
<pre><code>private String sparseSwitch(int age) {  
    String str = null;  
    switch (age) {  
        case 5:  
            str = &quot;he is a baby&quot;;  
            break;  
        case 15:  
            str = &quot;he is a student&quot;;  
            break;  
        case 35:  
            str = &quot;he is a father&quot;;  
            break;  
        case 65:  
            str = &quot;he is a grandpa&quot;;  
            break;  
        default:  
            str = &quot;he is a person&quot;;  
            break;  
    }  
    return str;  
} 

.method private sparseSwitch(I)Ljava/lang/String;  
    .locals 1  
    .parameter &quot;age&quot;  
    .prologue  
    .line 43  
    const/4 v0, 0x0  
    .line 44  
    .local v0, str:Ljava/lang/String;  
    sparse-switch p1, :sswitch_data_0  # sparse-switch分支，sswitch_data_0指定case区域  
    .line 58  
    const-string v0, &quot;he is a person&quot;  #case default  
    .line 61  
    :goto_0    #case 出口  
    return-object v0  #返回字符串  
    .line 46  
    :sswitch_0    #case 5  
    const-string v0, &quot;he is a baby&quot;  
    .line 47  
    goto :goto_0 #跳转到goto_0标号处  
    .line 49  
    :sswitch_1    #case 15  
    const-string v0, &quot;he is a student&quot;  
    .line 50  
    goto :goto_0 #跳转到goto_0标号处  
    .line 52  
    :sswitch_2    #case 35  
    const-string v0, &quot;he is a father&quot;  
    .line 53  
    goto :goto_0 #跳转到goto_0标号处  
    .line 55  
    :sswitch_3    #case 65  
    const-string v0, &quot;he is a grandpa&quot;  
    .line 56  
    goto :goto_0 #跳转到goto_0标号处  
    .line 44  
    nop  
    :sswitch_data_0  
    .sparse-switch            #case 区域  
        0x5 -&gt; :sswitch_0     #case 5(0x5)  
        0xf -&gt; :sswitch_1     #case 15(0xf)  
        0x23 -&gt; :sswitch_2    #case 35(0x23)  
        0x41 -&gt; :sswitch_3    #case 65(0x41)  
    .end sparse-switch  
.end method 
</code></pre><h3 id="try-catch语句"><a href="#try-catch语句" class="headerlink" title="try/catch语句"></a>try/catch语句</h3><pre><code>private void throw2() {
    try {
        throw new Exception(&quot;test throw runtime exception&quot;);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

.method private throw2()V
    .locals 3

    .prologue
    .line 31
    :try_start_0
    new-instance v1, Ljava/lang/Exception;

    const-string v2, &quot;test throw runtime exception&quot;

    invoke-direct {v1, v2}, Ljava/lang/Exception;-&gt;&lt;init&gt;(Ljava/lang/String;)V

    throw v1
    :try_end_0
    .catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0

    .line 32
    :catch_0
    move-exception v0

    .line 33
    .local v0, &quot;e&quot;:Ljava/lang/Exception;
    invoke-virtual {v0}, Ljava/lang/Exception;-&gt;printStackTrace()V

    .line 35
    return-void
.end method
</code></pre><h2 id="头信息——类的主体信息"><a href="#头信息——类的主体信息" class="headerlink" title="头信息——类的主体信息"></a>头信息——类的主体信息</h2><p>在打开smali文件的时候，它的头三行描述了当前类的一些信息。<br>    .class &lt;访问权限&gt; [关键修饰字] &lt;类名&gt;;<br>    .super &lt;父类名&gt;;<br>    .source &lt;源文件名&gt;</p>
<p>例如：</p>
<pre><code>//===================================================================
public class MainActivity extends AppCompatActivity {
    // ......
}
//===================================================================
.class public Ltestdemo/hpp/cn/test/MainActivity;
.super Landroid/support/v7/app/AppCompatActivity;
.source &quot;MainActivity.java&quot;
//===================================================================
</code></pre><p>.class指令表示当前的类名，类的访问权限是public，类名为Ltestdemo/hpp/cn/test/MainActivity，类开头的L是遵循Dalvik字节码的相关约定，表示后面跟随的字符串是一个类。</p>
<p>.super指定了当前类所继承的父类，后面指的就是这个父类的类名，L表示后面跟的字符串是一个类</p>
<p>.source指定了当前类的源文件名</p>
<p>注意：经过混淆的dex文件，反编译出来的smali代码可能没有源文件信息，因此source行的代码可能为空。</p>
<p>这三行就是类的主体部分了，另外一个类是由多个字段或者方法组成。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>如果一个类实现了一个接口，那么会在smali文件中使用.implements指令指出。</p>
<pre><code>#interfaces
.implements &lt;接口名&gt;
</code></pre><p>同样，#interfaces是注释，.implements是接口关键字。</p>
<p>例如：</p>
<pre><code>//===================================================================
public class MainActivity extends AppCompatActivity implements View.OnClickListener {
    // ......
}
//===================================================================
# interfaces
.implements Landroid/view/View$OnClickListener;
//===================================================================
</code></pre><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><p>smali文件中，字段的声明使用.field指令，字段分为静态字段和实例字段。</p>
<p>1 、静态字段</p>
<pre><code>#static fields
.field &lt;访问权限&gt; static [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;
</code></pre><p>可以看到，baksmali在生成smali文件时，会在静态字段声明的起始处添加注释”static fields”，注释是以#开头。</p>
<p>访问权限包括：private、protected、public（三者之一）<br>修饰关键字为字段的其他属性，例如，final<br>字段名和类型就不用解释了</p>
<p>例如：</p>
<pre><code>//===================================================================
private  static final String TAG = &quot;MainActivity&quot;;
//===================================================================
# static fields
.field private static final TAG:Ljava/lang/String; = &quot;MainActivity&quot;
//===================================================================
</code></pre><p>2、 实例字段 </p>
<p>相比于静态自动就少了一个static的静态声明而已，其他都一样。</p>
<pre><code>#instance fields
.field &lt;访问权限&gt; [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;
</code></pre><p>例如：</p>
<pre><code>//===================================================================
private Button mButton;
//===================================================================
# instance fields
.field private mButton:Landroid/widget/Button;
//===================================================================
</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>smali的方法声明使用的.method指令，方法分为直接方法和虚方法两种。</p>
<p>1、直接方法<br>直接方法指的是该类中定义的方法。</p>
<pre><code>#direct methods
.method &lt;访问权限&gt; [修饰关键字] &lt;方法原型&gt;
    &lt;.registers&gt;
    [.param]
    [.prologue]
    [.line]
    &lt;.local&gt;
    &lt;代码体&gt;
.end method
</code></pre><p>#direct methods是注释，是baksmali添加的，访问权限和修饰关键字跟字段是一样的。<br>方法原型描述了方法的名称、参数与返回值。<br>.registers 指令指定了方法中寄存器的总数,这个数量是参数和本地变量总和。<br>.param表明了方法的参数，每个.param指令表示一个参数，方法使用了几个参数就有几个.parameter指令。<br>.prologue指定了代码的开始处，混淆过的代码可能去掉了该指令。<br>.line指明了该处代码在源代码中的行号，同样，混淆后的代码可能去掉了行号。<br>.local 使用这个指定表明方法中非参寄存器</p>
<pre><code>//===================================================================
private void print(String string) {
    Log.d(TAG, string);
}
//===================================================================
.method private print(Ljava/lang/String;)V
    .registers 3
    .param p1, &quot;string&quot;    # Ljava/lang/String;

    .prologue
    .line 29
    const-string v0, &quot;MainActivity&quot;

    invoke-static {v0, p1}, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I

    .line 30
    return-void
.end method
//===================================================================
</code></pre><p>2、虚方法<br>虚方法指的是从父类中继承的方法或者实现的接口的方法，它的声明跟直接方法相同，只是起始的初始为virtual methods</p>
<pre><code>//===================================================================
@Override
public void onClick(View view) {
    String str = &quot;Hello World!&quot;;
    print(str);
}
//===================================================================
# virtual methods
.method public onClick(Landroid/view/View;)V
    .registers 3
    .param p1, &quot;view&quot;    # Landroid/view/View;

    .prologue
    .line 24
    const-string v0, &quot;Hello World!&quot;

    .line 25
    .local v0, &quot;str&quot;:Ljava/lang/String;
    invoke-direct {p0, v0}, Ltestdemo/hpp/cn/annotationtest/MainActivity;-&gt;print(Ljava/lang/String;)V

    .line 26
    return-void
.end method
//===================================================================
</code></pre><p>3、静态方法</p>
<pre><code>//===================================================================
public static void setTag(String str) {
    TAG = str;
}
//===================================================================
.method public static setTag(Ljava/lang/String;)V
    .registers 1
    .param p0, &quot;str&quot;    # Ljava/lang/String;

    .prologue
    .line 64
    sput-object p0, Ltestdemo/hpp/cn/annotationtest/MainActivity;-&gt;TAG:Ljava/lang/String;

    .line 65
    return-void
.end method
//===================================================================
</code></pre><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>如果一个类使用了注解，那么smali中会使用.annotation指令。</p>
<pre><code>#annotations
.annotation [注解属性] &lt;注解类名&gt;
    [注解字段 = 值]
.end annotation
</code></pre><p>注解的作用范围可以是类、方法或者字段。如果注解的作用范围是类，.annotation指令会直接定义在smali文件中，如果是方法或者字段，.annotation指令则会包含在方法或者字段的定义中。</p>
<p>1、  注解类</p>
<pre><code>//===================================================================
@BindInt(100)
public class MainActivity extends AppCompatActivity {

}
//===================================================================
# annotations
.annotation build Ltestdemo/hpp/cn/annotationtest/BindInt;
    value = 0x64
.end annotation
//===================================================================
</code></pre><p>2、  注解字段</p>
<pre><code>//===================================================================
@BindView(R.id.button)
public Button mButton;
//===================================================================
# instance fields
.field public mButton:Landroid/widget/Button;
    .annotation build Lbutterknife/BindView;
        value = 0x7f0c0050
    .end annotation
.end field
//===================================================================
</code></pre><p>3、  注解方法</p>
<pre><code>//===================================================================
@OnClick(R.id.button)
public void click() {
    String str = &quot;Hello World!&quot;;
    print(str);
}
//===================================================================
# virtual methods
.method public click()V
    .registers 2
    .annotation build Lbutterknife/OnClick;
        value = {
            0x7f0c0050
        }
    .end annotation

    .prologue
    .line 29
    const-string v0, &quot;Hello World!&quot;

    .line 30
    .local v0, &quot;str&quot;:Ljava/lang/String;
    invoke-direct {p0, v0}, Ltestdemo/hpp/cn/annotationtest/MainActivity;-&gt;print(Ljava/lang/String;)V

    .line 31
    return-void
.end method
//===================================================================
</code></pre><h2 id="smali插桩"><a href="#smali插桩" class="headerlink" title="smali插桩"></a>smali插桩</h2><p>插桩的原理就是静态的修改apk的samli文件，然后重新打包。</p>
<p>1、使用上面的方法得到一个apk的smali文件</p>
<p>2、在关键部位添加自己的代码，需要遵循smili语法，例如在关键地方打log，输出关键信息</p>
<p>3、重新进行打包签名</p>
<p><a href="http://drops.wooyun.org/papers/6045" target="_blank" rel="external">具体例子参考文章</a></p>
<h2 id="代码安全，防解密"><a href="#代码安全，防解密" class="headerlink" title="代码安全，防解密"></a>代码安全，防解密</h2><p>完全避免破解是不可能的，尽最大可能提高破解成本。</p>
<ul>
<li>混淆代码。代码混淆后，Smali更加晦涩难懂，逻辑也更难掌握。</li>
<li>解读汇编比解读Smali难度大的多得多。重要的逻辑可以放到C/C++层去处理就不要放在Java层上去处理。</li>
<li>多用连续调用的方式。这样出来的效果是Java只有一行，Smali可能有好几十行，增加查看难度。在一些关键的点上，比如支付，多绕一下。不要直接在Java内用中文显示标注等</li>
</ul>
<p>﻿﻿### <em>参考链接</em></p>
<ul>
<li><a href="https://blog.csdn.net/hp910315/article/details/51823236" target="_blank" rel="external">静态分析Android程序——smali文件解析</a></li>
<li><a href="https://blog.csdn.net/lkgmfjk/article/details/51202095" target="_blank" rel="external">Smali和逆向分析</a></li>
<li><a href="https://blog.csdn.net/qq_36869808/article/details/79111845" target="_blank" rel="external">Android逆向-java代码基础</a></li>
<li><a href="https://blog.csdn.net/l25000/article/details/46842013" target="_blank" rel="external">android逆向分析之smali语法</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/29/smali-语法/" data-id="cjfthdfco000ivz7qbquzwzh9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-阿里云ECS-CentOS系统搭建LAMP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/01/阿里云ECS-CentOS系统搭建LAMP/" class="article-date">
  <time datetime="2017-11-01T04:51:14.000Z" itemprop="datePublished">2017-11-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/other/">其他</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/01/阿里云ECS-CentOS系统搭建LAMP/">阿里云ECS CentOS系统搭建LAMP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>   作为PHP自学新手，买了阿里云ECS低配，摸索着弄个服务器，用来PHP前端的学习实践。各种百度，实践操作总结如下，分享给如我一般的菜鸟同学。</p>
<h2 id="认识CentOS系统"><a href="#认识CentOS系统" class="headerlink" title="认识CentOS系统"></a>认识CentOS系统</h2><p>  （百度）centos是linux系统的一个发行版。也就是linux系统中的一个。它是基于linux红帽版本制作的。红帽版因为是商业版，所以很多东西是要钱的。但是centos完全免费，主要用作服务器的搭建。</p>
<p>  LAMP环境，即Linux、Apache、MySQL、PHP环境。centos是Linux系统，接下来就只要装Apache、MySQL、PHP就好。</p>
<h2 id="安装-Apache"><a href="#安装-Apache" class="headerlink" title="安装 Apache"></a>安装 Apache</h2><pre><code>//安装
[root@izm5eicge3x0nikiewxdz8z ~]# yum install httpd httpd-devel

//查看是否已经安装
[root@izm5eicge3x0nikiewxdz8z ~]# yum list installed | grep httpd

//结果显示，说明已经安装成功
httpd.x86_64                            2.4.6-67.el7.centos.6          @updates 
httpd-devel.x86_64                      2.4.6-67.el7.centos.6          @updates 
httpd-tools.x86_64                      2.4.6-67.el7.centos.6          @updates 

//运行
[root@izm5eicge3x0nikiewxdz8z ~]# systemctl start httpd
[root@izm5eicge3x0nikiewxdz8z ~]# systemctl restart httpd

//查看80端口是否被监听.有,说明已启动
[root@izm5eicge3x0nikiewxdz8z ~]# netstat -ant 
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     
tcp        0      0 172.31.79.65:59786      140.205.140.205:80      ESTABLISHED

tcp        0      0 172.31.79.65:22         115.236.163.195:56720   ESTABLISHED
tcp        0     52 172.31.79.65:22         115.236.163.195:60099   ESTABLISHED
</code></pre><h2 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h2><pre><code>[root@izm5eicge3x0nikiewxdz8z ~]# yum install mysql mysql-server

//查看安装后的MySql的服务是否已经启动
[root@izm5eicge3x0nikiewxdz8z www]# service mysqld status 

// 没启动则启动MySQL服务
[root@izm5eicge3x0nikiewxdz8z www]# service mysqld start
</code></pre><h2 id="安装-PHP"><a href="#安装-PHP" class="headerlink" title="安装 PHP"></a>安装 PHP</h2><pre><code>//检查是否已经安装
[root@izm5eicge3x0nikiewxdz8z ~]# yum list installed | grep php

//安装
[root@izm5eicge3x0nikiewxdz8z ~]# yum install php php-devel 

//安装插件
[root@izm5eicge3x0nikiewxdz8z ~]#  yum install php-mysql php-gd php-xml   php-imap php-ldap php-odbc php-pear php-xmlrpc 
</code></pre><h2 id="安装结束"><a href="#安装结束" class="headerlink" title="安装结束"></a>安装结束</h2><h3 id="重启Apache服务器"><a href="#重启Apache服务器" class="headerlink" title="重启Apache服务器"></a>重启Apache服务器</h3><pre><code>[root@izm5eicge3x0nikiewxdz8z www]# systemctl restart httpd
</code></pre><h3 id="安装目录介绍"><a href="#安装目录介绍" class="headerlink" title="安装目录介绍"></a>安装目录介绍</h3><p>Apache默认将网站的根目录指向/var/www/html 目录<br>默认的主配置文件是/etc/httpd/conf/httpd.conf<br>配置存储在的/etc/httpd/conf.d/目录</p>
<h3 id="设置mysql数据库密码"><a href="#设置mysql数据库密码" class="headerlink" title="设置mysql数据库密码"></a>设置mysql数据库密码</h3><pre><code>//获取零时密码
[root@izm5eicge3x0nikiewxdz8z ~]# grep &apos;temporary password&apos; /var/log/mysqld.log

// 用临时密码登入mysql
[root@izm5eicge3x0nikiewxdz8z ~]# mysql -u root -p 

// 设置密码
mysql&gt; USE MYSQL
ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.

mysql&gt; SET PASSWORD FOR &apos;root&apos;@&apos;localhost&apos;=&apos;PwPw_123123&apos;;
mysql&gt; use mysql
mysql&gt; show tables;
mysql&gt; desc user;
</code></pre><h3 id="测试mysql是否链接成功的php代码"><a href="#测试mysql是否链接成功的php代码" class="headerlink" title="测试mysql是否链接成功的php代码"></a>测试mysql是否链接成功的php代码</h3><pre><code>&lt;?php
$con = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;PwPw_123123&quot;); //主机名，用户，密码
if (!$con)
  {
  die(&apos;Could not connect: &apos; . mysql_error());
  }

mysql_select_db(&quot;mydb&quot;, $con);

$result = mysql_query(&quot;SELECT * FROM sys_user&quot;);

while($row = mysql_fetch_array($result))
  {
  echo $row[&apos;UserName&apos;] . &quot; &quot; . $row[&apos;PassWord&apos;] . &quot; &quot; . $row[&apos;id&apos;];
  echo &quot;&lt;br /&gt;&quot;;
  }

mysql_close($con);
?&gt;
</code></pre><p>可以把上面的代码传入目录/var/www/html/<br>就可以看到执行情况</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/01/阿里云ECS-CentOS系统搭建LAMP/" data-id="cjfthdfdb0014vz7q6x19320a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/环境搭建/">环境搭建</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Gradle-for-Android" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/09/Gradle-for-Android/" class="article-date">
  <time datetime="2017-03-09T09:01:42.000Z" itemprop="datePublished">2017-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/09/Gradle-for-Android/">Gradle for Android</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="对Gradle的基本理解"><a href="#对Gradle的基本理解" class="headerlink" title="对Gradle的基本理解"></a>对Gradle的基本理解</h2><p>  一个基于Gradle的Android工程，必须有一个build.grade构建脚本，而我们用Android Studio创建工程时，Studio以为我们自动生成了该脚本文件。每个Module也会对应各自的一个构建脚本build.grade文件。</p>
<p>  Gradle脚本不是像传统的xml文件那样，而是一种基于Groovy的动态DSL，而Groovy语言是一种基于jvm的动态语言。</p>
<p>  在grade中两大概念：project和tasks。<br>  Android studio中的project和Gradle中的project不是一个概念。<br>  每个project有至少一个tasks。每一个build.grade文件代表着一个project。tasks在build.gradle中定义。<br>  当初始化构建进程，gradle会基于build文件，集合所有的project和tasks,一个tasks包含了一系列动作，<br>  然后它们将会按照顺序执行，一个动作就是一段被执行的代码，很像Java中的方法。</p>
<h2 id="Android中的Gradle脚本文件"><a href="#Android中的Gradle脚本文件" class="headerlink" title="Android中的Gradle脚本文件"></a>Android中的Gradle脚本文件</h2><h3 id="Android的build-gradle"><a href="#Android的build-gradle" class="headerlink" title="Android的build.gradle"></a>Android的build.gradle</h3><pre><code>buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.2.3&apos;
    } 
}
</code></pre><p>这就是实际构建开始的地方，仓库地址，使用了JCenter，JCenter类似maven库，grade还支持其他几个仓库，不论是远程还是本地仓库。</p>
<p>每个Module构建脚本的第一行都会声明使用什么插件：</p>
<pre><code>apply plugin: &apos;com.android.application&apos;
</code></pre><p>每个Android应用都需要一个插件：’com.android.application’；依赖库插件为’com.android.library’。（两插件不能同时使用）<br>插件用于扩展gradle脚本的能力，在一个项目中使用插件，这样该项目的构建脚本就可以定义该插件定义好的属性和使用它的tasks。</p>
<p>当使用Android 插件的时候，Android标签将可以被使用，如：</p>
<pre><code>android {
    compileSdkVersion 22
    buildToolsVersion &quot;22.0.1&quot;

    //设置代码文件源，一般用于导入旧的eclipse Android工程
    sourceSets {
        main {
            manifest.srcFile &apos;AndroidManifest.xml&apos;
            java.srcDirs = [&apos;src&apos;]
            resources.srcDirs = [&apos;src&apos;]
            aidl.srcDirs = [&apos;src&apos;]
            renderscript.srcDirs = [&apos;src&apos;]
            res.srcDirs = [&apos;res&apos;]
            assets.srcDirs = [&apos;assets&apos;]
        }
        androidTest.setRoot(&apos;tests&apos;)
    }

}
</code></pre><h2 id="Gradle-基本构建命令"><a href="#Gradle-基本构建命令" class="headerlink" title="Gradle 基本构建命令"></a>Gradle 基本构建命令</h2><ul>
<li><p>tasks：命令行，导航到项目文件夹下，命令，列出所以可运行的tasks</p>
<p>  $ gradlew tasks </p>
</li>
<li><p>assemble：开发时，构建项目，你需要运行assemble task通过debug配置</p>
<p>  $ gradlew assembleDebug</p>
<p>该任务将会创建一个debug版本的app,同时Android插件会将其保存在MyApp/app/build/ outputs/apk目录下。</p>
</li>
<li><p>check 运行所以的checks,这意味着运行所有的tests在已连的设备或模拟器上</p>
</li>
<li><p>build 是check和assemble的集合体</p>
</li>
<li><p>clean 清楚项目的output文件</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/09/Gradle-for-Android/" data-id="cjfthdfc80007vz7qmqr98dm8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Gradle/">Gradle</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-手机如何伪装成电脑上网" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/24/手机如何伪装成电脑上网/" class="article-date">
  <time datetime="2017-02-24T06:22:14.000Z" itemprop="datePublished">2017-02-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>►<a class="article-category-link" href="/categories/programming/life/">生活</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/24/手机如何伪装成电脑上网/">手机如何伪装成电脑上网</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="手机浏览器上网"><a href="#手机浏览器上网" class="headerlink" title="手机浏览器上网"></a>手机浏览器上网</h2><p>  打开浏览器，点开浏览器的“设置”项（一般在页面下方图标为三个杠的菜单中），找到“设置”里“UA设置”；UA设置一般有四个选项“Android；iPhone；iPad；电脑”，默认是“Android”，改选为“电脑”即可。</p>
<h2 id="代码网络请求实现。"><a href="#代码网络请求实现。" class="headerlink" title="代码网络请求实现。"></a>代码网络请求实现。</h2><p>   通过抓包软件比对，设置浏览器UA选项前后发出去的数据请求，只是请求头user-agent字段不同；我们代码一般不特别设置user-agent字段，默认情况下是发出去的请求头是没有该字段的。于是要实现伪装，只要为请求头添加相应的user-agent字段即可。</p>
<p>   实例代码：</p>
<pre><code>Map&lt;String, String&gt; headers = new HashMap&lt;&gt;(); 
public void request(Context context, String url, final BaseCallback callback) {
    headers.clear();
    //伪装成电脑上网
    headers.put(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/534.20 (KHTML, likeGecko) Chrome/11.0.672.0 Safari/534.20&quot;); 
    RequestQueue queue = Volley.newRequestQueue(context);
    StringRequest stringRequest = new StringRequest(Request.Method.GET, url, new Response.Listener&lt;String&gt;() {
    @Override
        public void onResponse(String response) {
            WxLog.i(tag, &quot; getLoginUUID onResponse: &quot; + response);
            if (callback != null) {
            callback.onSuccess(response);
            }
        }
    },
    new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
            WxLog.i(tag, &quot; onErrorResponse&quot;);
            if (callback != null) {
                callback.onFailed(error.getMessage());
            }
        }
    }) {
    @Override
    public Map&lt;String, String&gt; getHeaders() throws AuthFailureError {
        return headers;
    }
    };
    queue.add(stringRequest);
}
</code></pre><h2 id="抓包工具推荐AnyProxy"><a href="#抓包工具推荐AnyProxy" class="headerlink" title="抓包工具推荐AnyProxy"></a>抓包工具推荐AnyProxy</h2><p>  网址 ：<a href="https://github.com/alibaba/anyproxy" target="_blank" rel="external">https://github.com/alibaba/anyproxy</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/24/手机如何伪装成电脑上网/" data-id="cjfthdfd8000yvz7qy299arns" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/其他/">其他</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android快捷获取设备IMEI号" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/04/Android快捷获取设备IMEI号/" class="article-date">
  <time datetime="2017-02-04T06:33:26.000Z" itemprop="datePublished">2017-02-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/04/Android快捷获取设备IMEI号/">Android快捷获取设备IMEI号</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="拨号界面输入字符-06"><a href="#拨号界面输入字符-06" class="headerlink" title="拨号界面输入字符 *#06"></a>拨号界面输入字符 *#06</h2><p><img src="http://oku6oiw6z.bkt.clouddn.com/B21B77B4C397C2C14C51607BFA9D1EFF.jpg" alt="快捷获取"></p>
<h2 id="编程获取"><a href="#编程获取" class="headerlink" title="编程获取"></a>编程获取</h2><pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt; 
TelephonyManager telephonyManager = (TelephonyManager) this.getSystemService(Context.TELEPHONY_SERVICE);
String IMEI = telephonyManager.getDeviceId();
</code></pre><h2 id="adb命令获得-（若手机手机是双卡双待的貌似不支持）"><a href="#adb命令获得-（若手机手机是双卡双待的貌似不支持）" class="headerlink" title="adb命令获得 （若手机手机是双卡双待的貌似不支持）"></a>adb命令获得 （若手机手机是双卡双待的貌似不支持）</h2><pre><code>adb shell dumpsys iphonesubinfo
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/04/Android快捷获取设备IMEI号/" data-id="cjfthdfc70005vz7qj2gvrnbi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-使用Runtime代码中安装APP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/21/使用Runtime代码中安装APP/" class="article-date">
  <time datetime="2017-01-21T10:29:25.000Z" itemprop="datePublished">2017-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/21/使用Runtime代码中安装APP/">使用Runtime代码中安装APP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>private void install( final String apkPath) {<br>// 安装<br>final Thread thread = new Thread() {<br>public void run() {<br>// install tmp.apk<br>Process rt = null;<br>try {<br>rt = Runtime.getRuntime().exec(“su”);<br>BufferedReader stdInput = new BufferedReader(new InputStreamReader(rt.getInputStream()));</p>
<p>DataOutputStream os = new DataOutputStream(rt.getOutputStream());<br>String cmd = “pm install -r -d “ + apkPath + “\n”;<br>os.writeBytes(cmd + “\n”);<br>os.flush();<br>os.writeBytes(“exit\n”);<br>rt.waitFor();</p>
<p>String std = null;<br>StringBuilder sb = new StringBuilder();</p>
<p>boolean isSuccess = true;<br>while ((std = stdInput.readLine()) != null) {<br>Log.i(UpdaterConfig.TAG, std);<br>sb.append(std);<br>if (FAILED_OUTPUT.equals(std)) {<br>isSuccess = false;<br>}<br>}<br>new File(apkPath).delete();<br>Log.i(UpdaterConfig.TAG, “install success”);<br>if (isSuccess) {<br>showToastMsg(“安装完成”);<br>startAppIfNeed();<br>} else {<br>showToastMsg(“安装异常”);<br>}<br>} catch (Exception e) {<br>e.printStackTrace();<br>Log.i(UpdaterConfig.TAG, “install failed”);<br>showToastMsg(“安装异常”);<br>}<br>}<br>};<br>thread.start();<br>}</p>
<p>private void startAppIfNeed() {<br>if (APP_PACKAGE_NAME.equals(mCurrentData.getPackageName())) {<br>try {<br>showToastMsg(“启动主程序”);<br>Intent intent = new Intent();<br>intent.setComponent(new ComponentName(APP_PACKAGE_NAME, APP_PACKAGE_NAME + “.MainActivity”));<br>intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);<br>intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>intent.putExtra(UpdaterConfig.EXTRA_RESULT, UpdaterConfig.RESULT_SUCCESS);<br>UpdaterApp.getInstance().startActivity(intent);<br>} catch (Exception e) {<br>Log.e(UpdaterConfig.TAG, e.getMessage(), e);<br>}<br>}S<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/21/使用Runtime代码中安装APP/" data-id="cjfthdfd4000svz7q9nh2hsgt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-终端常用命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/20/终端常用命令/" class="article-date">
  <time datetime="2017-01-20T06:07:43.000Z" itemprop="datePublished">2017-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/other/">其他</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/20/终端常用命令/">Mac终端常用命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="记住这些终端命令并应用起来，会带给你诸多便利。"><a href="#记住这些终端命令并应用起来，会带给你诸多便利。" class="headerlink" title="记住这些终端命令并应用起来，会带给你诸多便利。"></a>记住这些终端命令并应用起来，会带给你诸多便利。</h1><h2 id="Mac-osx系统采用Linux文件系统"><a href="#Mac-osx系统采用Linux文件系统" class="headerlink" title="Mac osx系统采用Linux文件系统."></a>Mac osx系统采用Linux文件系统.</h2><p>所有文件都挂载到更目录下，没有磁盘分区的概念；<br>区分大小写，A.txt和a.txt是不同的文件；<br>文件通配符为星号 * </p>
<h2 id="和"><a href="#和" class="headerlink" title="/和./"></a>/和./</h2><p>/表示根目录，./表示当前目录，<br>例如,列出根目录下文件用命令：ls /<br>列出当前目录下文件用命令：ls ./</p>
<h2 id="df和du，查看文件夹／文件大小"><a href="#df和du，查看文件夹／文件大小" class="headerlink" title="df和du，查看文件夹／文件大小"></a>df和du，查看文件夹／文件大小</h2><p>查看一级文件夹大小、使用比例、档案系统及其挂入点，但对文件却无能为力: df -h<br>参数 -h 表示使用「Human-readable」的输出，也就是在档案系统大小使用 GB、MB 等易读的格式。<br>查看文件及文件夹的大小 : du</p>
<h2 id="取得root权限"><a href="#取得root权限" class="headerlink" title="取得root权限"></a>取得root权限</h2><p>sudo -s<br><strong>输入时不会有任何提示，只管输完后按回车键</strong></p>
<h2 id="查看摸个命令的使用说明"><a href="#查看摸个命令的使用说明" class="headerlink" title="查看摸个命令的使用说明"></a>查看摸个命令的使用说明</h2><p>man 命令<br>如：man find</p>
<h2 id="Tab键，自动补全"><a href="#Tab键，自动补全" class="headerlink" title="Tab键，自动补全"></a>Tab键，自动补全</h2><p>如想输入 : cd /Users<br>只需要输入: cd /Us   按Tab  会自动补全为 ：cd /Users</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>列出文件<br>ls 参数 目录名<br>例如： ls -wla /Users/zhangdan/blog<br>参数：-w 显示中文，-l 详细信息， -a 包括隐藏文件 </p>
<p>新建文件夹<br>mkdir 文件夹名称</p>
<p>查找文件<br>find . -name 文件名<br>例如查找文件 android-interact.sh<br>find . -name “android-interact.sh”</p>
<p>切换目录<br>cd 目录名</p>
<p>拷贝文件<br>cp 参数 源文件 目标文件<br>例如 ： cp -r newtest ./backup<br>复制当前路径下文件夹newtest 到当前路径下文件夹backup中<br>参数 -r  表递归</p>
<p>删除<br>rm 参数 文件名<br>例 删除当前路径下backup中文件夹newtest和其下的所有文件： rm -rf ./backup/newtest<br>参数 -r 递归； -f 强制</p>
<p>移动<br>mv 源文件 目标文件夹</p>
<p>更改文件权限<br>chmod 参数 权限<br>例：把驱动目录下所有文件设定到root读写，其他用户只读<br>chmod -R 755 /System/Library/Extensions<br>参数R 表示递归，755表示各用户的权限  </p>
<p>获取当前路径<br>pwd</p>
<p>文件编辑<br>nano 文件名<br>编辑完成后 用 Ctrl ＋O 存盘，Ctrl＋X 退出<br>另一个文本编辑软件是 vi</p>
<p>执行脚本<br>sh 脚本文件<br>例如：<br>终端运行命令：nano ./delete<br>粘贴下面内容到文件delete<br>rm -rf /Users/zhangdan/Desktop/test<br>Ctrl ＋O 存盘，Ctrl＋X 退出<br>终端运行：sh ./delete<br>桌面上的test文件夹将被删除</p>
<p>比较两个目录的内容<br>dircmp dir1 dir2 </p>
<p>比较两个文件的不同<br>diff file1 file2</p>
<p>在文件中按模式查找<br>grep “^[a-zA-Z]” filename </p>
<p>统计文件的字符数、词数和行数<br>wc filename </p>
<p>显示进程当前状态<br>ps u </p>
<p>终止进程<br>kill -9 30142 </p>
<p>显示当前设备时间<br>date</p>
<p>列出最近执行过的 几条命令及编号<br>history </p>
<p>显示操作系统的有关信息<br>uname -a </p>
<p>清除屏幕或窗口内容<br>clear </p>
<p>显示当前所有设置过的环境变量<br>env </p>
<p>列出当前登录的所有用户<br>who </p>
<p>显示当前正进行操作的用户名<br>whoami </p>
<p>显示文件系统的总空间和可用空间<br>df /tmp </p>
<p>查询磁盘使用情况<br>du -k subdir </p>
<p>显示当前系统活动的总信息<br>w</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/20/终端常用命令/" data-id="cjfthdfda0011vz7q5zcjd74j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/其他/">其他</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Weex学习索引" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/27/Weex学习索引/" class="article-date">
  <time datetime="2016-10-27T03:09:36.000Z" itemprop="datePublished">2016-10-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/27/Weex学习索引/">Weex学习索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Weex的口号是“Write once, run everywhere”，支持iOS、安卓、YunOS及Web等多端部署，<br>能够完美兼顾性能与动态性，让移动开发者通过捷的前端语法写出Native级别的性能体验。<br>开发者只需要在自己的APP中嵌入Weex的SDK，就可以通过撰写HTML/CSS/JavaScript来开发Native级别的Weex界面。Weex界面的生成码其实就是一段很小的JS，可以像发布网页一样轻松部署在服务端，然后在APP中请求执行。</p>
<h2 id="官方首页"><a href="#官方首页" class="headerlink" title="官方首页"></a>官方首页</h2><ul>
<li><a href="http://alibaba.github.io/weex/index.html" target="_blank" rel="external">http://alibaba.github.io/weex/index.html</a></li>
</ul>
<h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><ul>
<li><a href="https://github.com/joggerplus/awesome-weex" target="_blank" rel="external">https://github.com/joggerplus/awesome-weex</a></li>
</ul>
<h2 id="android例子"><a href="#android例子" class="headerlink" title="android例子"></a>android例子</h2><ul>
<li><a href="https://github.com/kingofglory/weex-demo" target="_blank" rel="external">https://github.com/kingofglory/weex-demo</a></li>
</ul>
<h2 id="weex基本原理"><a href="#weex基本原理" class="headerlink" title="weex基本原理"></a>weex基本原理</h2><p>提前了解：</p>
<ul>
<li>node.js</li>
<li>js</li>
<li>css</li>
<li>css3</li>
<li>html</li>
<li><p><a href="http://www.csdn.net/article/1970-01-01/2825439" target="_blank" rel="external">vue mvvm </a></p>
</li>
<li><p><a href="http://blog.csdn.net/walid1992/article/details/51469986" target="_blank" rel="external">http://blog.csdn.net/walid1992/article/details/51469986</a></p>
</li>
<li><a href="http://coderyi.com/posts/weex1/" target="_blank" rel="external">http://coderyi.com/posts/weex1/</a></li>
<li><a href="https://github.com/weexteam/article/issues/32" target="_blank" rel="external">https://github.com/weexteam/article/issues/32</a></li>
</ul>
<h2 id="weex使用入门"><a href="#weex使用入门" class="headerlink" title="weex使用入门"></a>weex使用入门</h2><ul>
<li><a href="http://alibaba.github.io/weex/index.html" target="_blank" rel="external">http://alibaba.github.io/weex/index.html</a></li>
<li><a href="https://github.com/vczero/weex-learning" target="_blank" rel="external">https://github.com/vczero/weex-learning</a></li>
<li><a href="https://alibaba.github.io/weex/doc/syntax/data-binding.html" target="_blank" rel="external">https://alibaba.github.io/weex/doc/syntax/data-binding.html</a></li>
</ul>
<h2 id="js-css基础补充"><a href="#js-css基础补充" class="headerlink" title="js css基础补充"></a>js css基础补充</h2><ul>
<li><a href="http://www.runoob.com/css/css-tutorial.html" target="_blank" rel="external">http://www.runoob.com/css/css-tutorial.html</a></li>
<li><a href="http://www.cnblogs.com/myzhibie/p/4318904.html" target="_blank" rel="external">flex http://www.cnblogs.com/myzhibie/p/4318904.html</a></li>
<li><a href="http://caibaojian.com/flexbox-guide.html" target="_blank" rel="external">http://caibaojian.com/flexbox-guide.html</a></li>
<li><a href="http://www.cnblogs.com/dolphinX/archive/2012/10/13/2722501.html" target="_blank" rel="external">http://www.cnblogs.com/dolphinX/archive/2012/10/13/2722501.html</a></li>
</ul>
<h2 id="推荐开发工具"><a href="#推荐开发工具" class="headerlink" title="推荐开发工具"></a>推荐开发工具</h2><ul>
<li><p><a href="http://wiki.jikexueyuan.com/project/atom/preview-html.html" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/atom/preview-html.html</a></p>
</li>
<li><p>webstorm</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/27/Weex学习索引/" data-id="cjfthdfcb0009vz7q423wpa86" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/weex/">weex</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编程语言/">编程语言</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/资料索引/">资料索引</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android之代码性能优化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/28/Android之代码性能优化/" class="article-date">
  <time datetime="2016-07-28T12:12:52.000Z" itemprop="datePublished">2016-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/28/Android之代码性能优化/">Android之代码性能优化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>对于占用系统资源，两条基本原则：不要做不必要的事；不要分配不必要的内存。</em></p>
<h2 id="1-避免建立对象"><a href="#1-避免建立对象" class="headerlink" title="1.    避免建立对象"></a>1.    避免建立对象</h2><p>对象都需要占用系统内存。除非必要，应尽量避免创建对象实例。</p>
<p>Primitive数据类型内存占用情况（单位：Byte）：<br>byte 1 ；short 2 ; int 4 ; long 8; float 4;double 8 ;boolean 1 ;char 2</p>
<p>例如  long[] data = new long[100]<br>占用内存8*1000 Bytes ，data本身是一个Object，也需占用内存。</p>
<p>Java中一个引用占4byte ，在32位系统上<br>Object obj=null;        //4byte<br>Object[] objs=new Object[1000]; //至少4*1000byte</p>
<p>一个对象使用的内存量，需要将所有实例变量使用的内存与对象本身的开销（一般是16个字节）相加。这些开销包括一个指向对象的类的引用、垃圾收集信息以及同步信息。另外，一般内存的使用都会被填充为8个字节的倍数。<br>一个Integer对象会使用24字节（16个字节的对象开销，4个字节用于保存它的int值以及4个填充字节）。<br>注明：64位操作系统对象开销为16，引用为8；32位系统，对象开销8，应用为4Bytes</p>
<h2 id="2-使用本地方法"><a href="#2-使用本地方法" class="headerlink" title="2.    使用本地方法"></a>2.    使用本地方法</h2><h2 id="3-使用实现类比接口好"><a href="#3-使用实现类比接口好" class="headerlink" title="3.    使用实现类比接口好"></a>3.    使用实现类比接口好</h2><h2 id="4-避免使用内部的getter／setter方法"><a href="#4-避免使用内部的getter／setter方法" class="headerlink" title="4.    避免使用内部的getter／setter方法"></a>4.    避免使用内部的getter／setter方法</h2><h2 id="5-优先使用改进的for循环，在性能要求苛刻的Arraylist迭代中，考虑采用手写计数循环。"><a href="#5-优先使用改进的for循环，在性能要求苛刻的Arraylist迭代中，考虑采用手写计数循环。" class="headerlink" title="5.    优先使用改进的for循环，在性能要求苛刻的Arraylist迭代中，考虑采用手写计数循环。"></a>5.    优先使用改进的for循环，在性能要求苛刻的Arraylist迭代中，考虑采用手写计数循环。</h2><h2 id="6-避免使用枚举，"><a href="#6-避免使用枚举，" class="headerlink" title="6.    避免使用枚举，"></a>6.    避免使用枚举，</h2><h2 id="7-避免使用浮点数。Android设备中，通常浮点数比整数慢两倍"><a href="#7-避免使用浮点数。Android设备中，通常浮点数比整数慢两倍" class="headerlink" title="7.    避免使用浮点数。Android设备中，通常浮点数比整数慢两倍"></a>7.    避免使用浮点数。Android设备中，通常浮点数比整数慢两倍</h2><h2 id="8-避免深度继承：子类的构建会导致父类的递归构建"><a href="#8-避免深度继承：子类的构建会导致父类的递归构建" class="headerlink" title="8.    避免深度继承：子类的构建会导致父类的递归构建"></a>8.    避免深度继承：子类的构建会导致父类的递归构建</h2><h2 id="9-谨慎使用异常，且不要在循环中使用try／catch"><a href="#9-谨慎使用异常，且不要在循环中使用try／catch" class="headerlink" title="9.    谨慎使用异常，且不要在循环中使用try／catch"></a>9.    谨慎使用异常，且不要在循环中使用try／catch</h2><h2 id="10-慎用static"><a href="#10-慎用static" class="headerlink" title="10.    慎用static"></a>10.    慎用static</h2><p>尽可能将常量定义为static final类型：当没有final修饰时，即为变量，访问时通过地址字段查找，取得具体内容；而常量不需要经过查找<br>例如 ：static final int intVal=10; //引用intVal的代码，将直接调用整型值10</p>
<h2 id="11-使用局部变量"><a href="#11-使用局部变量" class="headerlink" title="11.    使用局部变量"></a>11.    使用局部变量</h2><p>调用方法时传递的参数以及在方法中创建的零时变量都是保存在栈（stack）中，速度较快。其他变量都在堆（Heap）中创建。</p>
<h2 id="12-乘法和除法用移位操作符代替：左移-lt-lt-1位相当于乘以2"><a href="#12-乘法和除法用移位操作符代替：左移-lt-lt-1位相当于乘以2" class="headerlink" title="12.    乘法和除法用移位操作符代替：左移 &lt;&lt;1位相当于乘以2"></a>12.    乘法和除法用移位操作符代替：左移 &lt;&lt;1位相当于乘以2</h2><h2 id="13-集合类"><a href="#13-集合类" class="headerlink" title="13.    集合类"></a>13.    集合类</h2><ul>
<li>非线程安全的性能较好。Vector , HashTable 是线程安全的，ArrayList和HashMap不是</li>
<li>Iterator遍历比直接遍历慢</li>
<li>LinkedList插入和删除元素比ArrayList快</li>
<li>固定长度的集合数组较高效：Vector的默认存储能力为10个元素，每次扩展长度时默认自动加一倍，ArrayList是原来的50%。每次扩展，需要将所有现有元素复制到新空间，原先的数组再被回收，比较费时。</li>
</ul>
<h2 id="14-I-O操作优化"><a href="#14-I-O操作优化" class="headerlink" title="14.    I/O操作优化"></a>14.    I/O操作优化</h2><ul>
<li>字节流性能优于字符流操作：基于字节操作的I/O接口：InputStream和OutputStream；字符：Writer和Reader</li>
<li>使用缓存优化性能（BufferedInputStream,BufferedReader）</li>
<li>及时关闭I/O流，释放资源</li>
</ul>
<h2 id="15-字符串连接使用StringBuffer-StringBuilder-后者非线程安全，性能更好"><a href="#15-字符串连接使用StringBuffer-StringBuilder-后者非线程安全，性能更好" class="headerlink" title="15.    字符串连接使用StringBuffer/StringBuilder(后者非线程安全，性能更好)"></a>15.    字符串连接使用StringBuffer/StringBuilder(后者非线程安全，性能更好)</h2><h2 id="16-System-arraycopy（）代替通过循环复制数组"><a href="#16-System-arraycopy（）代替通过循环复制数组" class="headerlink" title="16.    System.arraycopy（）代替通过循环复制数组"></a>16.    System.arraycopy（）代替通过循环复制数组</h2><h2 id="17-避免在循环中调用同步方法"><a href="#17-避免在循环中调用同步方法" class="headerlink" title="17.    避免在循环中调用同步方法"></a>17.    避免在循环中调用同步方法</h2><h2 id="18-使用条件操作符代替简单的if语句"><a href="#18-使用条件操作符代替简单的if语句" class="headerlink" title="18.    使用条件操作符代替简单的if语句"></a>18.    使用条件操作符代替简单的if语句</h2><h2 id="19-强引用、弱引用、软引用、虚引用"><a href="#19-强引用、弱引用、软引用、虚引用" class="headerlink" title="19.    强引用、弱引用、软引用、虚引用"></a>19.    强引用、弱引用、软引用、虚引用</h2><h2 id="20-用static修饰的变量属于类，生命周期很长，应尽量避免static成员变量引用资源消耗过多的实例；Context尽量使用application-context；使用弱引用代替强引用，如可以用WeakReference-mContext"><a href="#20-用static修饰的变量属于类，生命周期很长，应尽量避免static成员变量引用资源消耗过多的实例；Context尽量使用application-context；使用弱引用代替强引用，如可以用WeakReference-mContext" class="headerlink" title="20.    用static修饰的变量属于类，生命周期很长，应尽量避免static成员变量引用资源消耗过多的实例；Context尽量使用application context；使用弱引用代替强引用，如可以用WeakReference mContext"></a>20.    用static修饰的变量属于类，生命周期很长，应尽量避免static成员变量引用资源消耗过多的实例；Context尽量使用application context；使用弱引用代替强引用，如可以用WeakReference mContext</h2><h2 id="21-线程的生命周期不可控，需谨慎对待"><a href="#21-线程的生命周期不可控，需谨慎对待" class="headerlink" title="21.    线程的生命周期不可控，需谨慎对待"></a>21.    线程的生命周期不可控，需谨慎对待</h2><h2 id="22-图片资源注意及时recycle，压缩减低内存消耗，巧用软引用"><a href="#22-图片资源注意及时recycle，压缩减低内存消耗，巧用软引用" class="headerlink" title="22.    图片资源注意及时recycle，压缩减低内存消耗，巧用软引用"></a>22.    图片资源注意及时recycle，压缩减低内存消耗，巧用软引用</h2><h2 id="23-Cursor及时close"><a href="#23-Cursor及时close" class="headerlink" title="23.    Cursor及时close"></a>23.    Cursor及时close</h2><h2 id="24-onTouchEvent-方法Action-move-事件处理频率控制"><a href="#24-onTouchEvent-方法Action-move-事件处理频率控制" class="headerlink" title="24.    onTouchEvent 方法Action_move 事件处理频率控制"></a>24.    onTouchEvent 方法Action_move 事件处理频率控制</h2><h2 id="25-ListView充分使用缓存机制"><a href="#25-ListView充分使用缓存机制" class="headerlink" title="25.    ListView充分使用缓存机制"></a>25.    ListView充分使用缓存机制</h2><h2 id="26-Android-TraceView-MemoryAnalyzer-分析内存使用情况"><a href="#26-Android-TraceView-MemoryAnalyzer-分析内存使用情况" class="headerlink" title="26.    Android TraceView + MemoryAnalyzer 分析内存使用情况"></a>26.    Android TraceView + MemoryAnalyzer 分析内存使用情况</h2><ul>
<li>TraceView使用：在DDMS中选中线程，单击“Method Profiling”（stop按钮的左边），…，单击“Method Profiling”按钮停止。然后会相应窗口会弹出</li>
<li>导出heap信息<strong>.hprof，在sdk的tools命令下，命令行执行如下命令，讲导出的hprof文件转换成MemoryAnalyzer支持的格式：hprof-conv  </strong>.hprof  newfile.hprof  </li>
</ul>
<h3 id="转载请注明出处"><a href="#转载请注明出处" class="headerlink" title="转载请注明出处"></a>转载请注明出处</h3><p><a href="http://andr112.github.io/2016/07/28/Android%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" target="_blank" rel="external">http://andr112.github.io/2016/07/28/Android%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</a></p>
<hr>
<p><a href="http://wenku.uml.com.cn/document.asp?fileid=12887&amp;partname=%CA%D6%BB%FA%BF%AA%B7%A2" target="_blank" rel="external">原文地址</a><br><a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="external">MemoryAnalyzer下载</a><br><a href="http://wangzzu.github.io/2016/05/07/java-object-memory/" target="_blank" rel="external">Java内存占用参考文献1</a><br><a href="http://javag.iteye.com/blog/319286" target="_blank" rel="external">Java内存占用参考文献2</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/28/Android之代码性能优化/" data-id="cjfthdfbz0001vz7qbi2v42j5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/代码/">代码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/优化/">优化</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/other/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/programming/">编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/programming/life/">生活</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/">Gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JNI/">JNI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weex/">weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/书籍/">书籍</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码/">代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优化/">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他/">其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/实践/">实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境搭建/">环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活美物/">生活美物</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经验/">经验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程语言/">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/资料索引/">资料索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/问题/">问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阅读/">阅读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/JNI/" style="font-size: 10px;">JNI</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/weex/" style="font-size: 10px;">weex</a> <a href="/tags/书籍/" style="font-size: 10px;">书籍</a> <a href="/tags/代码/" style="font-size: 10px;">代码</a> <a href="/tags/优化/" style="font-size: 10px;">优化</a> <a href="/tags/其他/" style="font-size: 15px;">其他</a> <a href="/tags/实践/" style="font-size: 10px;">实践</a> <a href="/tags/环境搭建/" style="font-size: 15px;">环境搭建</a> <a href="/tags/生活美物/" style="font-size: 10px;">生活美物</a> <a href="/tags/经验/" style="font-size: 15px;">经验</a> <a href="/tags/编程语言/" style="font-size: 10px;">编程语言</a> <a href="/tags/资料索引/" style="font-size: 10px;">资料索引</a> <a href="/tags/问题/" style="font-size: 15px;">问题</a> <a href="/tags/阅读/" style="font-size: 10px;">阅读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/03/彻底搞懂Android文件存储-内部存储，外部存储以及各种存储路径/">彻底搞懂Android文件存储(内部存储，外部存储以及各种存储路径)</a>
          </li>
        
          <li>
            <a href="/2018/03/29/smali-语法/">smali 语法</a>
          </li>
        
          <li>
            <a href="/2017/11/01/阿里云ECS-CentOS系统搭建LAMP/">阿里云ECS CentOS系统搭建LAMP</a>
          </li>
        
          <li>
            <a href="/2017/03/09/Gradle-for-Android/">Gradle for Android</a>
          </li>
        
          <li>
            <a href="/2017/02/24/手机如何伪装成电脑上网/">手机如何伪装成电脑上网</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Zhangdan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>