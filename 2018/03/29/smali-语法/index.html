<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>smali 语法 | 胖墩记忆</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="smali是什么Smali是Dalvik的寄存器语言，它与Java的关系，简单理解就是汇编之于C。
smali文件是哪来的，获取方法Smali代码是安卓APK反编译而来的。Smali文件和Java文件一一对应。获取Smali文件，我们需要下载一个辅助工具：ApkTool 。apktool这个命令行工具，最常用的命令有：

反编译decode：  apktool d xxx.apk
打包build：">
<meta property="og:type" content="article">
<meta property="og:title" content="smali 语法">
<meta property="og:url" content="http://yoursite.com/2018/03/29/smali-语法/index.html">
<meta property="og:site_name" content="胖墩记忆">
<meta property="og:description" content="smali是什么Smali是Dalvik的寄存器语言，它与Java的关系，简单理解就是汇编之于C。
smali文件是哪来的，获取方法Smali代码是安卓APK反编译而来的。Smali文件和Java文件一一对应。获取Smali文件，我们需要下载一个辅助工具：ApkTool 。apktool这个命令行工具，最常用的命令有：

反编译decode：  apktool d xxx.apk
打包build：">
<meta property="og:updated_time" content="2018-04-02T10:46:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="smali 语法">
<meta name="twitter:description" content="smali是什么Smali是Dalvik的寄存器语言，它与Java的关系，简单理解就是汇编之于C。
smali文件是哪来的，获取方法Smali代码是安卓APK反编译而来的。Smali文件和Java文件一一对应。获取Smali文件，我们需要下载一个辅助工具：ApkTool 。apktool这个命令行工具，最常用的命令有：

反编译decode：  apktool d xxx.apk
打包build：">
  
    <link rel="alternate" href="/atom.xml" title="胖墩记忆" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">胖墩记忆</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">小胖胖的学习、工作和生活...</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-smali-语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/29/smali-语法/" class="article-date">
  <time datetime="2018-03-29T05:17:07.000Z" itemprop="datePublished">2018-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/programming/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      smali 语法
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="smali是什么"><a href="#smali是什么" class="headerlink" title="smali是什么"></a>smali是什么</h2><p>Smali是Dalvik的寄存器语言，它与Java的关系，简单理解就是汇编之于C。</p>
<h2 id="smali文件是哪来的，获取方法"><a href="#smali文件是哪来的，获取方法" class="headerlink" title="smali文件是哪来的，获取方法"></a>smali文件是哪来的，获取方法</h2><p>Smali代码是安卓APK反编译而来的。Smali文件和Java文件一一对应。获取Smali文件，我们需要下载一个辅助工具：ApkTool 。apktool这个命令行工具，最常用的命令有：</p>
<ul>
<li>反编译decode：<br>  apktool d xxx.apk</li>
<li>打包build：<br>  apktool b</li>
</ul>
<h2 id="Smali语法"><a href="#Smali语法" class="headerlink" title="Smali语法"></a>Smali语法</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><pre><code>V void (只能用于返回值类型) 
Z boolean
B byte
S short
C char
I int
J long（64位）
F float
D double（64位）
</code></pre><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>Lpackage/ObjectName; 相当于java中的package.ObjectName;<br>L 表示这是一个对象类型<br>package 该对象所在的包<br>ObjectName 对象名称<br>; 标识对象名称的结束<br>例如：Ltestdemo/hpp/cn/test/MainActivity;Ljava/lang/String;</p>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>[I :表示一个整形的一维数组，相当于java的int[];<br>对于多维数组，只要增加[ 就行了，[[I = int[][];注：每一维最多255个；</p>
<p>对象数组的表示形式：<br>[Ljava/lang/String 表示一个String的对象数组；</p>
<h3 id="寄存器与变量"><a href="#寄存器与变量" class="headerlink" title="寄存器与变量"></a>寄存器与变量</h3><p>android变量都是存放在寄存器中的，寄存器为32位，可以支持任何类型，其中long和double是64为的，需要使用两个寄存器保存。<br>寄存器采用v和p来命名，v表示本地寄存器，p表示参数寄存器。</p>
<p>例如：</p>
<pre><code>//===================================================================
private void print(String string) {
    Log.d(TAG, string);
}
//===================================================================
.method private print(Ljava/lang/String;)V
    .registers 3
    .param p1, &quot;string&quot;    # Ljava/lang/String;

    .prologue
    .line 29
    const-string v0, &quot;MainActivity&quot;

    invoke-static {v0, p1}, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I

    .line 30
    return-void
.end method
//===================================================================
</code></pre><p>.registers 3 说明该方法有三个寄存器，其中一个本地寄存器v0，两个参数寄存器p0,p1，细心的人可能会注意到没有看到p0，原因是p0存放的是this。如果是静态方法的话就只有2个寄存器了，不需要存this了。</p>
<h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><p>smali字节码是类似于汇编，如果有汇编基础，理解起来是非常容易的。<br>    move v0, v3 把v3寄存器的值移动到寄存器v0上<br>    const-string v0, “MainActivity” 把字符串”MainActivity”赋值给v0寄存器<br>    invoke-super　　调用父函数<br>    return-void　　函数返回void<br>    new-instance　　创建实例<br>    iput-object　　对象赋值<br>    iget-object　　调用对象<br>    invoke-static　　调用静态函数<br>    invoke-direct　　调用函数</p>
<p>例如：</p>
<pre><code>//===================================================================
@Override
public void onClick(View view) {
    String str = &quot;Hello World!&quot;;
    print(str);
}
//===================================================================
# virtual methods
# 参数类型为Landroid/view/View，返回类型为V
.method public onClick(Landroid/view/View;)V
    # 表示有三个寄存器
    .registers 3
    # 参数View类型的view变量对应的是寄存器p1
    .param p1, &quot;view&quot;    # Landroid/view/View;

    .prologue
    .line 24
    #将&quot;Hello World!&quot;字符串放到寄存器v0中
    const-string v0, &quot;Hello World!&quot;

    .line 25
    # 定义一个Ljava/lang/String类型的str变量对应本地寄存器v0
    .local v0, &quot;str&quot;:Ljava/lang/String;
    # 调用该类的print方法，该方法的参数类型为Ljava/lang/String，返回值为V
    # 调用print方法传入的参数为{p0, v0}，及print(p0, v0)，p0为this，v0为&quot;Hello World!&quot;字符串
    invoke-direct {p0, v0}, Ltestdemo/hpp/cn/annotationtest/MainActivity;-&gt;print(Ljava/lang/String;)V

    .line 26
    return-void
.end method
//===================================================================
</code></pre><h3 id="if判断语句"><a href="#if判断语句" class="headerlink" title="if判断语句"></a>if判断语句</h3><p>if判断一共有12条指令：</p>
<pre><code>if-eq vA, VB, cond_** 如果vA等于vB则跳转到cond_**。相当于if (vA==vB)
if-ne vA, VB, cond_** 如果vA不等于vB则跳转到cond_**。相当于if (vA!=vB)
if-lt vA, VB, cond_** 如果vA小于vB则跳转到cond_**。相当于if (vA&lt;vB)
if-le vA, VB, cond_** 如果vA小于等于vB则跳转到cond_**。相当于if (vA&lt;=vB)
if-gt vA, VB, cond_** 如果vA大于vB则跳转到cond_**。相当于if (vA&gt;vB)
if-ge vA, VB, cond_** 如果vA大于等于vB则跳转到cond_**。相当于if (vA&gt;=vB)

if-eqz vA, :cond_** 如果vA等于0则跳转到:cond_** 相当于if (VA==0)
if-nez vA, :cond_** 如果vA不等于0则跳转到:cond_**相当于if (VA!=0)
if-ltz vA, :cond_** 如果vA小于0则跳转到:cond_**相当于if (VA&lt;0)
if-lez vA, :cond_** 如果vA小于等于0则跳转到:cond_**相当于if (VA&lt;=0)
if-gtz vA, :cond_** 如果vA大于0则跳转到:cond_**相当于if (VA&gt;0)
if-gez vA, :cond_** 如果vA大于等于0则跳转到:cond_**相当于if (VA&gt;=0)
</code></pre><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>常用的循环结构有：迭代器循环，for循环，do while循环。</p>
<pre><code>import java.util.*;

public class demo{
    public static void main(String[]args)
    {
        Scanner s=new Scanner(System.in);
        int[] arr=new int[5];
        for(int i=0;i&lt;5;i++)
        {
            arr[i]=s.nextInt();
        }  
        for (int i:arr)
        {
            System.out.println(i);
        }

    }
}

.class public Ldemo;
.super Ljava/lang/Object;
.source &quot;demo.java&quot;


# direct methods
.method public constructor &lt;init&gt;()V
    .registers 1

    .prologue
    .line 3
    invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V

    return-void
.end method

.method public static main([Ljava/lang/String;)V
    .registers 7

    .prologue
    const/4 v5, 0x5

    const/4 v0, 0x0

    .line 6
    new-instance v2, Ljava/util/Scanner;

    sget-object v1, Ljava/lang/System;-&gt;in:Ljava/io/InputStream;

    invoke-direct {v2, v1}, Ljava/util/Scanner;-&gt;&lt;init&gt;(Ljava/io/InputStream;)V

    .line 7
    new-array v3, v5, [I

    move v1, v0

    .line 8
    :goto_c
    if-ge v1, v5, :cond_17

    .line 10
    invoke-virtual {v2}, Ljava/util/Scanner;-&gt;nextInt()I

    move-result v4

    aput v4, v3, v1

    .line 8
    add-int/lit8 v1, v1, 0x1

    goto :goto_c

    .line 12
    :cond_17
    array-length v1, v3

    :goto_18
    if-ge v0, v1, :cond_24

    aget v2, v3, v0

    .line 14
    sget-object v4, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;

    invoke-virtual {v4, v2}, Ljava/io/PrintStream;-&gt;println(I)V

    .line 12
    add-int/lit8 v0, v0, 0x1

    goto :goto_18

    .line 17
    :cond_24
    return-void
.end method
</code></pre><h3 id="switch分支语句"><a href="#switch分支语句" class="headerlink" title="switch分支语句"></a>switch分支语句</h3><p>1、case值递增的有规律 switch</p>
<pre><code>private String packedSwitch(int i) {  
    String str = null;  
    switch (i) {  
        case 0:  
            str = &quot;she is a baby&quot;;  
            break;  
        case 1:  
            str = &quot;she is a girl&quot;;  
            break;  
        case 2:  
            str = &quot;she is a woman&quot;;  
            break;  
        case 3:  
            str = &quot;she is an obasan&quot;;  
            break;  
        default:  
            str = &quot;she is a person&quot;;  
            break;  
    }  
    return str;  
}  

.method private packedSwitch(I)Ljava/lang/String;  
    .locals 1  
    .parameter &quot;i&quot;  
    .prologue  
    .line 21  
    const/4 v0, 0x0  
    .line 22  
    .local v0, str:Ljava/lang/String;  #v0为字符串，0表示null  
    packed-switch p1, :pswitch_data_0  #packed-switch分支，pswitch_data_0指定case区域  
    .line 36  
    const-string v0, &quot;she is a person&quot;  #default分支  
    .line 39  
    :goto_0      #所有case的出口  
    return-object v0 #返回字符串v0  
    .line 24  
    :pswitch_0    #case 0  
    const-string v0, &quot;she is a baby&quot;  
    .line 25  
    goto :goto_0  #跳转到goto_0标号处  
    .line 27  
    :pswitch_1    #case 1  
    const-string v0, &quot;she is a girl&quot;  
    .line 28  
    goto :goto_0  #跳转到goto_0标号处  
    .line 30  
    :pswitch_2    #case 2  
    const-string v0, &quot;she is a woman&quot;  
    .line 31  
    goto :goto_0  #跳转到goto_0标号处  
    .line 33  
    :pswitch_3    #case 3  
    const-string v0, &quot;she is an obasan&quot;  
    .line 34  
    goto :goto_0  #跳转到goto_0标号处  
    .line 22  
    nop  
    :pswitch_data_0  
    .packed-switch 0x0    #case  区域，从0开始，依次递增  
        :pswitch_0  #case 0  
        :pswitch_1  #case 1  
        :pswitch_2  #case 2  
        :pswitch_3  #case 3  
    .end packed-switch  
.end method
</code></pre><p>2、无规律的switch</p>
<pre><code>private String sparseSwitch(int age) {  
    String str = null;  
    switch (age) {  
        case 5:  
            str = &quot;he is a baby&quot;;  
            break;  
        case 15:  
            str = &quot;he is a student&quot;;  
            break;  
        case 35:  
            str = &quot;he is a father&quot;;  
            break;  
        case 65:  
            str = &quot;he is a grandpa&quot;;  
            break;  
        default:  
            str = &quot;he is a person&quot;;  
            break;  
    }  
    return str;  
} 

.method private sparseSwitch(I)Ljava/lang/String;  
    .locals 1  
    .parameter &quot;age&quot;  
    .prologue  
    .line 43  
    const/4 v0, 0x0  
    .line 44  
    .local v0, str:Ljava/lang/String;  
    sparse-switch p1, :sswitch_data_0  # sparse-switch分支，sswitch_data_0指定case区域  
    .line 58  
    const-string v0, &quot;he is a person&quot;  #case default  
    .line 61  
    :goto_0    #case 出口  
    return-object v0  #返回字符串  
    .line 46  
    :sswitch_0    #case 5  
    const-string v0, &quot;he is a baby&quot;  
    .line 47  
    goto :goto_0 #跳转到goto_0标号处  
    .line 49  
    :sswitch_1    #case 15  
    const-string v0, &quot;he is a student&quot;  
    .line 50  
    goto :goto_0 #跳转到goto_0标号处  
    .line 52  
    :sswitch_2    #case 35  
    const-string v0, &quot;he is a father&quot;  
    .line 53  
    goto :goto_0 #跳转到goto_0标号处  
    .line 55  
    :sswitch_3    #case 65  
    const-string v0, &quot;he is a grandpa&quot;  
    .line 56  
    goto :goto_0 #跳转到goto_0标号处  
    .line 44  
    nop  
    :sswitch_data_0  
    .sparse-switch            #case 区域  
        0x5 -&gt; :sswitch_0     #case 5(0x5)  
        0xf -&gt; :sswitch_1     #case 15(0xf)  
        0x23 -&gt; :sswitch_2    #case 35(0x23)  
        0x41 -&gt; :sswitch_3    #case 65(0x41)  
    .end sparse-switch  
.end method 
</code></pre><h3 id="try-catch语句"><a href="#try-catch语句" class="headerlink" title="try/catch语句"></a>try/catch语句</h3><pre><code>private void throw2() {
    try {
        throw new Exception(&quot;test throw runtime exception&quot;);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

.method private throw2()V
    .locals 3

    .prologue
    .line 31
    :try_start_0
    new-instance v1, Ljava/lang/Exception;

    const-string v2, &quot;test throw runtime exception&quot;

    invoke-direct {v1, v2}, Ljava/lang/Exception;-&gt;&lt;init&gt;(Ljava/lang/String;)V

    throw v1
    :try_end_0
    .catch Ljava/lang/Exception; {:try_start_0 .. :try_end_0} :catch_0

    .line 32
    :catch_0
    move-exception v0

    .line 33
    .local v0, &quot;e&quot;:Ljava/lang/Exception;
    invoke-virtual {v0}, Ljava/lang/Exception;-&gt;printStackTrace()V

    .line 35
    return-void
.end method
</code></pre><h2 id="头信息——类的主体信息"><a href="#头信息——类的主体信息" class="headerlink" title="头信息——类的主体信息"></a>头信息——类的主体信息</h2><p>在打开smali文件的时候，它的头三行描述了当前类的一些信息。<br>    .class &lt;访问权限&gt; [关键修饰字] &lt;类名&gt;;<br>    .super &lt;父类名&gt;;<br>    .source &lt;源文件名&gt;</p>
<p>例如：</p>
<pre><code>//===================================================================
public class MainActivity extends AppCompatActivity {
    // ......
}
//===================================================================
.class public Ltestdemo/hpp/cn/test/MainActivity;
.super Landroid/support/v7/app/AppCompatActivity;
.source &quot;MainActivity.java&quot;
//===================================================================
</code></pre><p>.class指令表示当前的类名，类的访问权限是public，类名为Ltestdemo/hpp/cn/test/MainActivity，类开头的L是遵循Dalvik字节码的相关约定，表示后面跟随的字符串是一个类。</p>
<p>.super指定了当前类所继承的父类，后面指的就是这个父类的类名，L表示后面跟的字符串是一个类</p>
<p>.source指定了当前类的源文件名</p>
<p>注意：经过混淆的dex文件，反编译出来的smali代码可能没有源文件信息，因此source行的代码可能为空。</p>
<p>这三行就是类的主体部分了，另外一个类是由多个字段或者方法组成。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>如果一个类实现了一个接口，那么会在smali文件中使用.implements指令指出。</p>
<pre><code>#interfaces
.implements &lt;接口名&gt;
</code></pre><p>同样，#interfaces是注释，.implements是接口关键字。</p>
<p>例如：</p>
<pre><code>//===================================================================
public class MainActivity extends AppCompatActivity implements View.OnClickListener {
    // ......
}
//===================================================================
# interfaces
.implements Landroid/view/View$OnClickListener;
//===================================================================
</code></pre><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><p>smali文件中，字段的声明使用.field指令，字段分为静态字段和实例字段。</p>
<p>1 、静态字段</p>
<pre><code>#static fields
.field &lt;访问权限&gt; static [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;
</code></pre><p>可以看到，baksmali在生成smali文件时，会在静态字段声明的起始处添加注释”static fields”，注释是以#开头。</p>
<p>访问权限包括：private、protected、public（三者之一）<br>修饰关键字为字段的其他属性，例如，final<br>字段名和类型就不用解释了</p>
<p>例如：</p>
<pre><code>//===================================================================
private  static final String TAG = &quot;MainActivity&quot;;
//===================================================================
# static fields
.field private static final TAG:Ljava/lang/String; = &quot;MainActivity&quot;
//===================================================================
</code></pre><p>2、 实例字段 </p>
<p>相比于静态自动就少了一个static的静态声明而已，其他都一样。</p>
<pre><code>#instance fields
.field &lt;访问权限&gt; [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;
</code></pre><p>例如：</p>
<pre><code>//===================================================================
private Button mButton;
//===================================================================
# instance fields
.field private mButton:Landroid/widget/Button;
//===================================================================
</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>smali的方法声明使用的.method指令，方法分为直接方法和虚方法两种。</p>
<p>1、直接方法<br>直接方法指的是该类中定义的方法。</p>
<pre><code>#direct methods
.method &lt;访问权限&gt; [修饰关键字] &lt;方法原型&gt;
    &lt;.registers&gt;
    [.param]
    [.prologue]
    [.line]
    &lt;.local&gt;
    &lt;代码体&gt;
.end method
</code></pre><p>#direct methods是注释，是baksmali添加的，访问权限和修饰关键字跟字段是一样的。<br>方法原型描述了方法的名称、参数与返回值。<br>.registers 指令指定了方法中寄存器的总数,这个数量是参数和本地变量总和。<br>.param表明了方法的参数，每个.param指令表示一个参数，方法使用了几个参数就有几个.parameter指令。<br>.prologue指定了代码的开始处，混淆过的代码可能去掉了该指令。<br>.line指明了该处代码在源代码中的行号，同样，混淆后的代码可能去掉了行号。<br>.local 使用这个指定表明方法中非参寄存器</p>
<pre><code>//===================================================================
private void print(String string) {
    Log.d(TAG, string);
}
//===================================================================
.method private print(Ljava/lang/String;)V
    .registers 3
    .param p1, &quot;string&quot;    # Ljava/lang/String;

    .prologue
    .line 29
    const-string v0, &quot;MainActivity&quot;

    invoke-static {v0, p1}, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I

    .line 30
    return-void
.end method
//===================================================================
</code></pre><p>2、虚方法<br>虚方法指的是从父类中继承的方法或者实现的接口的方法，它的声明跟直接方法相同，只是起始的初始为virtual methods</p>
<pre><code>//===================================================================
@Override
public void onClick(View view) {
    String str = &quot;Hello World!&quot;;
    print(str);
}
//===================================================================
# virtual methods
.method public onClick(Landroid/view/View;)V
    .registers 3
    .param p1, &quot;view&quot;    # Landroid/view/View;

    .prologue
    .line 24
    const-string v0, &quot;Hello World!&quot;

    .line 25
    .local v0, &quot;str&quot;:Ljava/lang/String;
    invoke-direct {p0, v0}, Ltestdemo/hpp/cn/annotationtest/MainActivity;-&gt;print(Ljava/lang/String;)V

    .line 26
    return-void
.end method
//===================================================================
</code></pre><p>3、静态方法</p>
<pre><code>//===================================================================
public static void setTag(String str) {
    TAG = str;
}
//===================================================================
.method public static setTag(Ljava/lang/String;)V
    .registers 1
    .param p0, &quot;str&quot;    # Ljava/lang/String;

    .prologue
    .line 64
    sput-object p0, Ltestdemo/hpp/cn/annotationtest/MainActivity;-&gt;TAG:Ljava/lang/String;

    .line 65
    return-void
.end method
//===================================================================
</code></pre><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>如果一个类使用了注解，那么smali中会使用.annotation指令。</p>
<pre><code>#annotations
.annotation [注解属性] &lt;注解类名&gt;
    [注解字段 = 值]
.end annotation
</code></pre><p>注解的作用范围可以是类、方法或者字段。如果注解的作用范围是类，.annotation指令会直接定义在smali文件中，如果是方法或者字段，.annotation指令则会包含在方法或者字段的定义中。</p>
<p>1、  注解类</p>
<pre><code>//===================================================================
@BindInt(100)
public class MainActivity extends AppCompatActivity {

}
//===================================================================
# annotations
.annotation build Ltestdemo/hpp/cn/annotationtest/BindInt;
    value = 0x64
.end annotation
//===================================================================
</code></pre><p>2、  注解字段</p>
<pre><code>//===================================================================
@BindView(R.id.button)
public Button mButton;
//===================================================================
# instance fields
.field public mButton:Landroid/widget/Button;
    .annotation build Lbutterknife/BindView;
        value = 0x7f0c0050
    .end annotation
.end field
//===================================================================
</code></pre><p>3、  注解方法</p>
<pre><code>//===================================================================
@OnClick(R.id.button)
public void click() {
    String str = &quot;Hello World!&quot;;
    print(str);
}
//===================================================================
# virtual methods
.method public click()V
    .registers 2
    .annotation build Lbutterknife/OnClick;
        value = {
            0x7f0c0050
        }
    .end annotation

    .prologue
    .line 29
    const-string v0, &quot;Hello World!&quot;

    .line 30
    .local v0, &quot;str&quot;:Ljava/lang/String;
    invoke-direct {p0, v0}, Ltestdemo/hpp/cn/annotationtest/MainActivity;-&gt;print(Ljava/lang/String;)V

    .line 31
    return-void
.end method
//===================================================================
</code></pre><h2 id="smali插桩"><a href="#smali插桩" class="headerlink" title="smali插桩"></a>smali插桩</h2><p>插桩的原理就是静态的修改apk的samli文件，然后重新打包。</p>
<p>1、使用上面的方法得到一个apk的smali文件</p>
<p>2、在关键部位添加自己的代码，需要遵循smili语法，例如在关键地方打log，输出关键信息</p>
<p>3、重新进行打包签名</p>
<p><a href="http://drops.wooyun.org/papers/6045" target="_blank" rel="external">具体例子参考文章</a></p>
<h2 id="代码安全，防解密"><a href="#代码安全，防解密" class="headerlink" title="代码安全，防解密"></a>代码安全，防解密</h2><p>完全避免破解是不可能的，尽最大可能提高破解成本。</p>
<ul>
<li>混淆代码。代码混淆后，Smali更加晦涩难懂，逻辑也更难掌握。</li>
<li>解读汇编比解读Smali难度大的多得多。重要的逻辑可以放到C/C++层去处理就不要放在Java层上去处理。</li>
<li>多用连续调用的方式。这样出来的效果是Java只有一行，Smali可能有好几十行，增加查看难度。在一些关键的点上，比如支付，多绕一下。不要直接在Java内用中文显示标注等</li>
</ul>
<p>﻿﻿### <em>参考链接</em></p>
<ul>
<li><a href="https://blog.csdn.net/hp910315/article/details/51823236" target="_blank" rel="external">静态分析Android程序——smali文件解析</a></li>
<li><a href="https://blog.csdn.net/lkgmfjk/article/details/51202095" target="_blank" rel="external">Smali和逆向分析</a></li>
<li><a href="https://blog.csdn.net/qq_36869808/article/details/79111845" target="_blank" rel="external">Android逆向-java代码基础</a></li>
<li><a href="https://blog.csdn.net/l25000/article/details/46842013" target="_blank" rel="external">android逆向分析之smali语法</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/29/smali-语法/" data-id="cjfi41ffc0009i37q5d3oji0x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/11/01/阿里云ECS-CentOS系统搭建LAMP/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">阿里云ECS CentOS系统搭建LAMP</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-smali-语法" data-title="smali 语法" data-url="http://yoursite.com/2018/03/29/smali-语法/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'andr112'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  </section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/other/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/programming/">编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/programming/life/">生活</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/">Gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JNI/">JNI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weex/">weex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/书籍/">书籍</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码/">代码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优化/">优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他/">其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/实践/">实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境搭建/">环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活美物/">生活美物</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/经验/">经验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编程语言/">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/资料索引/">资料索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/问题/">问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阅读/">阅读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/JNI/" style="font-size: 10px;">JNI</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/weex/" style="font-size: 10px;">weex</a> <a href="/tags/书籍/" style="font-size: 10px;">书籍</a> <a href="/tags/代码/" style="font-size: 10px;">代码</a> <a href="/tags/优化/" style="font-size: 10px;">优化</a> <a href="/tags/其他/" style="font-size: 15px;">其他</a> <a href="/tags/实践/" style="font-size: 10px;">实践</a> <a href="/tags/环境搭建/" style="font-size: 15px;">环境搭建</a> <a href="/tags/生活美物/" style="font-size: 10px;">生活美物</a> <a href="/tags/经验/" style="font-size: 15px;">经验</a> <a href="/tags/编程语言/" style="font-size: 10px;">编程语言</a> <a href="/tags/资料索引/" style="font-size: 10px;">资料索引</a> <a href="/tags/问题/" style="font-size: 15px;">问题</a> <a href="/tags/阅读/" style="font-size: 10px;">阅读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/29/smali-语法/">smali 语法</a>
          </li>
        
          <li>
            <a href="/2017/11/01/阿里云ECS-CentOS系统搭建LAMP/">阿里云ECS CentOS系统搭建LAMP</a>
          </li>
        
          <li>
            <a href="/2017/03/09/Gradle-for-Android/">Gradle for Android</a>
          </li>
        
          <li>
            <a href="/2017/02/24/手机如何伪装成电脑上网/">手机如何伪装成电脑上网</a>
          </li>
        
          <li>
            <a href="/2017/02/04/Android快捷获取设备IMEI号/">Android快捷获取设备IMEI号</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Zhangdan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>